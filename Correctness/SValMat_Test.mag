clear;

///////////////////////////////////////////////////////////
//////// Testing: computing S-unit lattice    /////////////
///////////////////////////////////////////////////////////
//    Sumin Leem, 2023
//
// This script is to verify the correctness of SValMat,
// a function computing the S-valuation matrix 
// when a finite set S of places of a function field F is given.
//
///////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////
// Load files
///////////////////////////////////////////////////////////
load "testing_gen.mag";
load "functions.mag";


///////////////////////////////////////////////////////////////////////////////
// TESTING FUNCTION
// RunSValMatTest_randominput and RunSValMatTest return true 
// if SValMat computes a correct S-unit valuation matrix with given set S, 
// false otherwise.
///////////////////////////////////////////////////////////////////////////////
function RunSValMatTest_randominput(S)
    try 
        M:=SValMat(S);
    catch e
        "Failed to compute an S-unit valuation matrix";
        e;
        return false;
    end try;

    if assigned M then
        // When given random set S, we compute a S-unit valuation matrix 
        // using Magma intrinsics and compare the lattice generated by the rows
        // of the matrix with the lattice generated by the rows 
        // of the output of SValMat(S).

        SU,m:=SUnitGroup({p: p in S});
        TFSU:=TorsionFreeSubgroup(SU);
        gen:=SetToIndexedSet(Generators(TFSU));
        if #gen eq 0 then
            if (Lattice(M) eq Lattice(Matrix(Integers(), 1,1,[1]))) then
                return true;
            else
                return false;    
            end if;
        else
            Mat:=Matrix(Integers(), #gen, #S, [[Valuation(m(gen[i]), S[j]): j in [1..#S]]: i in [1..#gen]]);

            if (Lattice(M) eq Lattice(Mat)) then
                return true;
            else
                return false;
            end if;
        end if;
    end if;
end function;



function RunSValMatTest(S, Mat)
    try 
        M:=SValMat(S);
    catch e
        "Failed to compute an S-unit valuation matrix";
        e;
        return false;
    end try;

    if assigned M then
        if (Lattice(M) eq Lattice(Mat)) then
            return true;
        else
            return false;
        end if;
    end if;
end function;





///////////////////////////////////////////////////////////////////////////////
//GLOBAL TESTING VARIABLES
///////////////////////////////////////////////////////////////////////////////
//Field sizes below 10 for auto gen cases
//Split curves do not exist for FF(2)
FIELDSIZE:= {3,4,5,7};
ExtensionDeg:= {2,3,4,5};
CoefficientDeg:= {2,3,4,5};
//RANK:={1..3};

PLACE_DEG:={1,2,3,4,5};
N_Random_Places:={1..5};

/////////////////////////////////////////////////////////////////////////////
//SET THE NUMBER OF REPETITION
///////////////////////////////////////////////////////////////////////////////
Rep:=10;


///////////////////////////////////////////////////////////////////////////////
//START TESTING
///////////////////////////////////////////////////////////////////////////////





// Start testing
for q in FIELDSIZE do

for repi in [1..Rep] do

    Fq:=GF(q);
    A<x>:=PolynomialRing(Fq);
    Ay<t>:=PolynomialRing(A);

    //// 1. Testing for a random function field F
    f:= gen_def_poly(Random(ExtensionDeg), Random(CoefficientDeg), q);
    F:=FunctionField(f);

    OF:=MaximalOrderFinite(F);
    inf:=InfinitePlaces(F);

    F`genus:=Genus(F);
    F`OF:=OF;
    F`infplaces:=inf;


    // 1-1. S is the set of all infinite places
    S1:={@ p: p in inf @};
    assert RunSValMatTest_randominput(S1);


    // 1-2. S contains finite places above g(x)
    g:=gen_random_poly(Random(PLACE_DEG),A);
    if g ne 0 then
        S2:={@ p: p in inf @} join {@ p: p in Zeros(F!g) @};
    end if;
    assert RunSValMatTest_randominput(S2);


    // 1-3. S contains random finite places
    S3:={@ p: p in inf @};
    l:=Random(N_Random_Places);
    for j in [1..l] do
        try
            pd:=Random(PLACE_DEG);
            set:={@ RandomPlace(F,pd) @};
        catch e
            delete pd;
        end try;
        if assigned set then
            S3:=S3 join set;
            delete set;
        end if;
    end for;
    assert RunSValMatTest_randominput(S3);



    // 2. Testing for a function field F that is inert at infinity.
    F:=F_with_inert_inf(q,Random(ExtensionDeg), Random(CoefficientDeg));

    OF:=MaximalOrderFinite(F);
    inf:=InfinitePlaces(F);

    F`genus:=Genus(F);
    F`OF:=OF;
    F`infplaces:=inf;


    // 2-1. S is the set of all infinite places
    S1:={@ p: p in inf @};
    assert RunSValMatTest_randominput(S1);


    // 2-2. S contains finite places above g(x) (valid input)
    g:=gen_random_poly(Random(PLACE_DEG),A);
    if g ne 0 then
        S2:={@ p: p in inf @} join {@ p: p in Zeros(F!g) @};
    end if;
    assert RunSValMatTest_randominput(S2);


    // 2-3. S contains random finite places (valid input)
    S3:={@ p: p in inf @};
    l:=Random(N_Random_Places);
    for j in [1..l] do
        try
            pd:=Random(PLACE_DEG);
            set:={@ RandomPlace(F,pd) @};
        catch e
            delete pd;
        end try;
        if assigned set then
            S3:=S3 join set;
            delete set;
        end if;
    end for;
    assert RunSValMatTest_randominput(S3);



    // 3. Testing for a function field F that is totally ramified at infinity.
    F:=F_total_ram_inf(q,Random(ExtensionDeg), Random(CoefficientDeg));

    OF:=MaximalOrderFinite(F);
    inf:=InfinitePlaces(F);

    F`genus:=Genus(F);
    F`OF:=OF;
    F`infplaces:=inf;


    // 3-1. S is the set of all infinite places (valid input)
    S1:={@ p: p in inf @};
    assert RunSValMatTest_randominput(S1);


    // 3-2. S contains finite places above g(x) (valid input)
    g:=gen_random_poly(Random(PLACE_DEG),A);
    if g ne 0 then
        S2:={@ p: p in inf @} join {@ p: p in Zeros(F!g) @};
    end if;
    assert RunSValMatTest_randominput(S2);


    // 3-3. S contains random finite places (valid input)
    S3:={@ p: p in inf @};
    l:=Random(N_Random_Places);
    for j in [1..l] do
        try
            pd:=Random(PLACE_DEG);
            set:={@ RandomPlace(F,pd) @};
        catch e
            delete pd;
        end try;
        if assigned set then
            S3:=S3 join set;
            delete set;
        end if;
    end for;
    assert RunSValMatTest_randominput(S3);



    // 4. Testing for each rank
    for n in ExtensionDeg do
        for r in [1..n-1] do
            F:=specified_rank_F(q,n,Random(CoefficientDeg),r);

            OF:=MaximalOrderFinite(F);
            inf:=InfinitePlaces(F);

            F`genus:=Genus(F);
            F`OF:=OF;
            F`infplaces:=inf;

            // 4-1. S is the set of all infinite places (valid input)
            S1:={@ p: p in inf @};
            assert RunSValMatTest_randominput(S1);


            // 4-2. S contains finite places above g(x) (valid input)
            g:=gen_random_poly(Random(PLACE_DEG),A);
            if g ne 0 then
                S2:={@ p: p in inf @} join {@ p: p in Zeros(F!g) @};
            end if;
            assert RunSValMatTest_randominput(S2);


            // 4-3. S contains random finite places (valid input)
            S3:={@ p: p in inf @};
            l:=Random(N_Random_Places);
            for j in [1..l] do
                try
                    pd:=Random(PLACE_DEG);
                    set:={@ RandomPlace(F,pd) @};
                catch e
                    delete pd;
                end try;
                if assigned set then
                    S3:=S3 join set;
                    delete set;
                end if;
            end for;
            assert RunSValMatTest_randominput(S3);

        end for;
    end for;
end for;
end for;





/////Test with pre-selected inputs
    Fq:=GF(5);
    A<x>:=PolynomialRing(Fq);
    Ay<t>:=PolynomialRing(A);

    //// 1. Testing for a random function field F
    f:= t^3 + 4*t^2 + (4*x + 3)*t + x^2 + 3*x + 1;
    F:=FunctionField(f);

    OF:=MaximalOrderFinite(F);
    inf:=InfinitePlaces(F);

    F`genus:=Genus(F);
    F`OF:=OF;
    F`infplaces:=inf;

    // 1-1. S is the set of all infinite places
    S1:={@ p: p in inf @};
    M1:=Matrix(Integers(), 1,1, [ 1 ]);
    assert RunSValMatTest(S1, M1);


    // 1-2. S contains finite places above g(x)=x^2+x
    S2:={@ p: p in inf @} join {@ Place(ideal<OF|x>), Place(ideal<OF|x+1>) @};
    M2:=Matrix(Integers(), 2, 3, 
        [[0,  1, -1],
         [3,  0, -1]]);
    assert RunSValMatTest(S2, M2);


    // 1-3. S contains random finite places
    S3:={@ p: p in inf @} join {@ Place(ideal<OF|x+4, F.1^2 + 4*F.1 + 2>), Place(ideal<OF|x^2+3, F.1+2>)@};
    M3:=Matrix(Integers(), 2, 3, 
        [[2,  0, -1], 
         [0,  2, -2]]);
    assert RunSValMatTest(S3, M3);



    // 2. Testing for a function field F that is inert at infinity.
    f:=t^3 + (3*x^2 + x + 1)*t^2 + x^3*t + 2*x^6 + 2*x^5;
    F:=FunctionField(f);

    OF:=MaximalOrderFinite(F);
    inf:=InfinitePlaces(F);

    F`genus:=Genus(F);
    F`OF:=OF;
    F`infplaces:=inf;


    // 2-1. S is the set of all infinite places
    S1:={@ p: p in inf @};
    M1:=Matrix(Integers(), 1, 1, [ 1 ]);
    assert RunSValMatTest(S1, M1);


    // 2-2. S contains finite places above g(x)=3*x^2+3*x
    S2:={@ p: p in inf @} join {@ Place(ideal<OF|x, F.1 + 1>), Place(ideal<OF|x, 2/x^2*F.1^2 + (2*x + 2)/x^2*F.1>), Place(ideal<OF|x + 1, F.1>), Place(ideal<OF|x + 1, F.1^2 + 3*F.1 + 4>) @};
    M2:=Matrix(Integers(), 4,5, 
        [[ 1,  0,  0, -1, -1], 
         [-1,  1,  2,  0,  0], 
         [ 0,  2, -1, -1,  0],
         [ 1,  2,  0,  5, -5]]);
    assert RunSValMatTest_randominput(S2);


    // 2-3. S contains random finite places (valid input)
    S3:={@ p: p in inf @} join {@ Place(ideal<OF|x^2 + x + 2, F.1 + 4>) @};
    M3:=Matrix(Integers(), 1, 2, [18, -27]);
    assert RunSValMatTest(S3, M3);



    // 3. Testing for a function field F that is totally ramified at infinity.
    f:=t^3 + t^2 + (4*x + 3)*t + 2*x^2 + 1;
    F:=FunctionField(f);

    OF:=MaximalOrderFinite(F);
    inf:=InfinitePlaces(F);

    F`genus:=Genus(F);
    F`OF:=OF;
    F`infplaces:=inf;


    // 3-1. S is the set of all infinite places
    S1:={@ p: p in inf @};
    M1:=Matrix(Integers(), 1, 1, [ 1 ]);
    assert RunSValMatTest(S1, M1);


    // 3-2. S contains finite places above g(x)=x+4
    S2:={@ p: p in inf @} join {@ Place(ideal<OF|x + 4, F.1 + 2>) @};
    M2:=Matrix(Integers(), 1, 2, [ 3, -3 ]);
    assert RunSValMatTest(S2, M2);


    // 3-3. S contains random finite places (Need to run again)
    S3:={@ p: p in inf @} join {@ Place(ideal<OF|x^2 + 4*x + 2, F.1 + 3>) @};
    M3:=Matrix(Integers(), 1, 2, [2, -1]);
    assert RunSValMatTest(S3, M3);



    // 4. Testing for each rank
    // 4.1 extension degree n =3, rank r=1
    f:=t^3 + (x^2 + x + 1)*t^2 + (4*x^2 + 4*x)*t + x^2 + 4*x + 2;
    F:=FunctionField(f);

    OF:=MaximalOrderFinite(F);
    inf:=InfinitePlaces(F);

    F`genus:=Genus(F);
    F`OF:=OF;
    F`infplaces:=inf;


    // 4.1-1. S is the set of all infinite places 
    S1:={@ p: p in inf @};
    M1:=Matrix(Integers(), 1, 2, [18, -9]);
    assert RunSValMatTest(S1, M1);


    // 4.1-2. S contains finite places above g(x)=x^2+4*x+2
    S2:={@ p: p in inf @} join {@ Place(ideal<OF|x^2 + 4*x + 2, F.1>), Place(ideal<OF|x^2 + 4*x + 2, F.1^2 + (2*x + 4)*F.1 + 3*x + 2>) @};
    M2:=Matrix(Integers(), 3, 4, 
        [[ 0,  2,  0, -1],
         [ 2,  0, -1,  0],
         [-4,  1, -7,  4]]);
    assert RunSValMatTest(S2, M2);


    // 4.1-3. S contains random finite places
    S3:={@ p: p in inf @} join {@ Place(ideal<OF|x + 2, F.1 + x + 1>) @};
    M3:=Matrix(Integers(), 2, 3, 
        [[  2,   0,  -2],
         [-10,   9,  -8]]);
    assert RunSValMatTest(S3, M3);




    // 4.2 extension degree n =3, rank r=2
    f:=t^3 + (x^2 + 3)*t^2 + t + x^2 + 3*x + 4;
    F:=FunctionField(f);

    OF:=MaximalOrderFinite(F);
    inf:=InfinitePlaces(F);

    F`genus:=Genus(F);
    F`OF:=OF;
    F`infplaces:=inf;


    // 4-1. S is the set of all infinite places 
    S1:={@ p: p in inf @};
    M1:=Matrix(Integers(), 2, 3, 
        [[ 2,  1, -3],
         [ 3, -5,  2]]);
    assert RunSValMatTest(S1, M1);


    // 4-2. S contains finite places above g(x)=x^2 + 4*x + 1
    S2:={@ p: p in inf @} join {@ Place(ideal<OF|x^2 + 4*x + 1, F.1 + 2*x + 4>) @};
    M2:=Matrix(Integers(), 3, 4, 
        [[-2, -1,  3,  0],
         [ 2,  2,  2, -3],
         [ 3, -5,  2,  0]]);
    assert RunSValMatTest(S2, M2);


    // 4-3. S contains random finite places
    S3:={@ p: p in inf @} join {@ Place(ideal<OF|x + 2, F.1 + 2>) @};
    M3:=Matrix(Integers(), 3, 4, 
        [[ 1, -2,  0,  1],
         [ 1, -1,  2, -2],
         [-3,  0,  1,  2]]);
    assert RunSValMatTest(S3, M3);


