AddAttribute(FldFun, "genus"); 
AddAttribute(FldFun, "infplaces");
AddAttribute(FldFun, "OF");
AddAttribute(FldFun, "OFi");



////////////////////////////////////////////////////////////////
///// IsAssociate
////////////////////////////////////////////////////////////////
// inputs: elt1 and elt2 are in the finite maximal order OF
// output: true if elt1 and elt2 are associate, and false otherwise.
////////////////////////////////////////////////////////////////
function IsAssociate(elt1, elt2, OF)
    error if not(elt1 in OF) or not(elt2 in OF), "Elements must be in OF";
    error if Type(OF) ne RngFunOrd, "OF must be RngFunOrd";

    fac1:=Factorization(elt1*OF); fac2:=Factorization(elt2*OF);
    S:={@ Place(fac1[i][1]): i in [1..#fac1] @} join {@ Place(fac2[i][1]): i in [1..#fac2] @};

    bool:=true;
    for i in [1..#S] do
        bool:=bool and (Valuation(elt1, S[i])-Valuation(elt2, S[i]) eq 0);
    end for;

    return bool;
end function;





////////////////////////////////////////////////////////////////
///// SValMat
////////////////////////////////////////////////////////////////
// input: an indexed set Sind of places that contains all the infinite places of a function field F
// output: a matrix whose rows form a basis of Sind-unit lattice
////////////////////////////////////////////////////////////////
function SValMat(Sind)

    F:=FunctionField(Universe(Sind));
    inf:=F`infplaces;

    error if { p: p in inf} diff {p: p in Sind} ne {}, "The input must contain all infinite places of F";

    if #Sind lt 2 then
        // Handling trivial cases: Sind contains less than 2 places
        k := ExactConstantField(F);
        US := AbelianGroup( [#k-1] );
        FToUS := function(a)
           if IsZero(a) then
              print "";
              error "Runtime error: Element is zero";
           end if;

           ok, b := IsConstant(a);

           if not ok then
              print "";
              error"Runtime error: Element has no preimage";
           end if;

           return US![ Log(b) ];

        end function;
      
        FToUSTest := function(a) // copy paste from above
           if IsZero(a) then
              return false, _;
           end if;

           ok, b := IsConstant(a);

           if not ok then
              return false, _;
           end if;

           return true, US![ Log(b) ];

        end function;
      
        a := F!PrimitiveElement(k);  
        f1 := map< US -> F | x :-> a^Eltseq(x)[1], y :-> FToUS(y) >;
        f1`PreimageTest := FToUSTest; 
        ZS:=Domain(f1);
        M := LLL(Matrix( Integers(), NumberOfGenerators(US), #Sind, [ Eltseq(ZS!a) : a in Generators(US) ] ));

        return M;
    else
        // When Sind contains 2 or more places
        _, _, f := ClassGroup(FunctionField(Universe(Sind)));
        fS := f( [ 1*P : P in Sind ] );
        ZS := FreeAbelianGroup(#Sind);
        g := hom< ZS -> Universe(fS)| fS >;
        M := LLL(Matrix( Integers(), NumberOfGenerators(U), #Sind, [ Eltseq(ZS!a) : a in Generators(U) ] ))
        where U := Kernel(g);

        return M;
    end if;

end function;






////////////////////////////////////////////////////////////////
///// CompactRep
////////////////////////////////////////////////////////////////
// inputs:
//// A: a principal ideal generated by alpha in F
//// v_alpha: the vector of the values of alpha at the infinite places
//// F: function field
// output: a compact representation of alpha
////////////////////////////////////////////////////////////////
function compactrep(A, v_alpha, F)
    OF:=F`OF; inf:=F`infplaces;
    g:=F`genus;

    error if #v_alpha ne #inf, "The length of the input vector must be the same with the number of infinite places";
    error if Universe(v_alpha) ne Integers(), "The vector must be an integer vector";

    // ind1 is a sequence of indices of degree 1 infinite places
    ind1:=[i: i in [1..#inf] | Degree(inf[i]) eq 1];
    error if ind1 eq [], "Cannot compute compact representation as there is no infinite place of degree 1";

    // Re-define ind1 as an index of a degree 1 infinite place
    ind1:=ind1[#ind1];


    // reduce function takes 2 inputs: an ideal I and an integer vector v. 
    //              It returns an element in I that is close to v.
    function reduce(I, v)
        D:=-Divisor(I)- &+[v[n]*inf[n]: n in {1..#inf}] + v[ind1]*inf[ind1];
        k1:=-Degree(D);
        //k2:=k1+g;

        // Find non-trivial Riemann-Roch space in [k1 .. k2]
        D:=D+(k1)*inf[ind1];
        b:=Basis(D);
        if #b ne 0 then
            return F!Eltseq(F!b[1]);
        end if;

        for k in [1 .. g] do
            D:=D+inf[ind1];
            b:=Basis(D);
            if #b ne 0 then
                return F!Eltseq(F!b[1]);
            end if;
        end for;
    end function;    

    function reduce2(D, v)
        D:=-D- &+[v[n]*inf[n]: n in {1..#inf}] + v[ind1]*inf[ind1];
        k1:=-Degree(D);
        //k2:=k1+g;

        // Find non-trivial Riemann-Roch space in [k1 .. k2]
        D:=D+(k1)*inf[ind1];
        b:=Basis(D);
        if #b ne 0 then
            return F!Eltseq(F!b[1]);
        end if;

        for k in [1 .. g] do
            D:=D+inf[ind1];
            b:=Basis(D);
            if #b ne 0 then
                return F!Eltseq(F!b[1]);
            end if;
        end for;
    end function;    



    // Find mu in the ideal A that is close to 0 vector (mu is a minimum of A)
    mu:=reduce2(Divisor(A),[0*i: i in [1..#inf]]);

    v_mualpha:=[Valuation(mu, inf[n])-v_alpha[n]: n in [1..#inf]];

    if IsZero(v_mualpha) then
        // handling a trivial case that mu is alpha*eta, where eta is a constant.
        return [mu, 1];
    else
        l:=Round(Log(2,Maximum(Abs(Minimum(v_mualpha)),Abs(Maximum(v_mualpha))))+1); 

        //// Computing beta_j for j=1, ..., l
        beta:=[F|];

        j:=1;
        D:=Divisor(F!1);
        t:=[Round(v_mualpha[n]/(2^(l-j))): n in {1..#inf}];

        beta[j]:=reduce2(D, t);

        // valb is to keep track of values of beta at the infinite places
        valb:=[Valuation(beta[j], inf[i]): i in [1..#inf]];

        for j in [2..l] do

            D:=-2*FiniteDivisor(Divisor(beta[j-1]))+2*D;
            t:=[Round(v_mualpha[n]/(2^(l-j))): n in {1..#inf}];

            beta[j]:=reduce2(D, [t[n]-2*valb[n]: n in [1..#inf]]);

            valb:=[2*valb[i]+Valuation(beta[j], inf[i]): i in [1..#inf]];
        end for;

        return [F!mu] cat beta;
    end if;

end function;







////////////////////////////////////////////////////////////////
///// MultCR
////////////////////////////////////////////////////////////////
// inputs: compact representations cr1 and cr2 of alpha1 and alpha2 in F
// output: a compact representation of alpha1*alpha2
////////////////////////////////////////////////////////////////
function mult_cr(cr1, cr2)
    error if Universe(cr1) ne Universe(cr2), "compact representations must be from the same function field.";

    n1:=#cr1; n2:=#cr2;
    F:=Universe(cr1);
    if n1 gt n2 then
        return [F!cr1[1]*F!cr2[1]] cat [F!cr1[i+1]: i in [1..n1-n2]] cat [F!cr1[n1-n2+i+1]*F!cr2[i+1]: i in [1..n2-1]];
    elif n1 eq n2 then
        return [F!cr1[i]*F!cr2[i]: i in [1..n2]];
    else
        return [F!cr1[1]*F!cr2[1]] cat [cr2[i+1]: i in [1..n2-n1]] cat [F!cr2[n2-n1+i+1]*F!cr1[i+1]: i in [1..n1-1]];

    end if;

end function;





////////////////////////////////////////////////////////////////
///// PowCR
////////////////////////////////////////////////////////////////
// inputs: a compact representation cr of alpha1 in F, and an integer n
// output: a compact representation of alpha1^n
////////////////////////////////////////////////////////////////
function power_cr(cr, n)
    F:=Universe(cr);
    return [F!cr[i]^n: i in [1..#cr]];

end function;




////////////////////////////////////////////////////////////////
///// NormCR
////////////////////////////////////////////////////////////////
// input: a compact representation of alpha1 in F
// output: Norm_{F/k(x)}(alpha1)
////////////////////////////////////////////////////////////////
function norm_cr(cr)

    error if #cr le 1, "compact representation is not valid";
    F:=Universe(cr);
    norm:=Norm(F!cr[1]) * &*[1/Norm(F!cr[j])^(2^(#cr-j)): j in [2..#cr]];

    return norm;

end function;


function norm_cr3(cr)

    error if #cr le 1, "compact representation is not valid";
    F:=Universe(cr);
    norm:=Norm(F!cr[1]) * &*[1/Norm(F!cr[j])^(3^(#cr-j)): j in [2..#cr]];

    return norm;

end function;




////////////////////////////////////////////////////////////////
///// valCR
////////////////////////////////////////////////////////////////
// input: a compact representation of alpha1 in F
// output: Valuation of alpha1 at P
////////////////////////////////////////////////////////////////
function val_cr(cr,P)

    error if #cr le 1, "compact representation is not valid";
    F:=Universe(cr);

    val:=Valuation(F!cr[1],P)- &+[2^(#cr-j)*Valuation(F!cr[j],P): j in [2..#cr]];

    return val;

end function;


function val_cr3(cr,P)

    error if #cr le 1, "compact representation is not valid";
    F:=Universe(cr);

    val:=Valuation(F!cr[1],P)- &+[3^(#cr-j)*Valuation(F!cr[j],P): j in [2..#cr]];

    return val;

end function;





////////////////////////////////////////////////////////////////
///// IsAssociateCR
////////////////////////////////////////////////////////////////
// inputs: elt1 and elt2 are in the finite maximal order OF, elt1 and elt2 are given in compact rep
// output: true if elt1 and elt2 are associate, and false otherwise.
////////////////////////////////////////////////////////////////
function IsAssociateCR(cr1, cr2, OF)
    error if Type(OF) ne RngFunOrd, "OF must be RngFunOrd";

    ideal1:=cr1[1]*OF;
    for i in [2..#cr1] do
        ideal1:=(1/cr1[i])*ideal1^2;
    end for;

    ideal2:=cr2[1]*OF;
    for i in [2..#cr2] do
        ideal2:=(1/cr2[i])*ideal2^2;
    end for;

    fac1:=Factorization(ideal1); fac2:=Factorization(ideal2);
    S:={@ Place(fac1[i][1]): i in [1..#fac1] @} join {@ Place(fac2[i][1]): i in [1..#fac2] @};

    bool:=true;
    for i in [1..#S] do
        bool:=bool and (val_cr(cr1,S[i])-val_cr(cr2, S[i]) eq 0);
    end for;

    return bool;
end function;




function IsAssociateCR3(cr1, cr2, OF)
    error if Type(OF) ne RngFunOrd, "OF must be RngFunOrd";

    ideal1:=cr1[1]*OF;
    for i in [2..#cr1] do
        ideal1:=(1/cr1[i])*ideal1^3;
    end for;

    ideal2:=cr2[1]*OF;
    for i in [2..#cr2] do
        ideal2:=(1/cr2[i])*ideal2^3;
    end for;

    fac1:=Factorization(ideal1); fac2:=Factorization(ideal2);
    S:={@ Place(fac1[i][1]): i in [1..#fac1] @} join {@ Place(fac2[i][1]): i in [1..#fac2] @};

    bool:=true;
    for i in [1..#S] do
        bool:=bool and (val_cr3(cr1,S[i])-val_cr3(cr2, S[i]) eq 0);
    end for;

    return bool;
end function;




////////////////////////////////////////////////////////////////
///// CRinOF
////////////////////////////////////////////////////////////////
// inputs: elt1 given in compact rep
// output: true if elt1 is in OF, and false otherwise.
////////////////////////////////////////////////////////////////
function CRinOF(cr1,OF)
    ideal1:=cr1[1]*OF;
    for i in [2..#cr1] do
        ideal1:=(1/cr1[i])*ideal1^2;
    end for;

    fac1:=Factorization(ideal1);
    S:={@ Place(fac1[i][1]): i in [1..#fac1] @};
    for i in [1..#S] do
        if val_cr(cr1,S[i]) lt 0 then
            return false;
        end if;
    end for;

    return true;
end function;


function CR3inOF(cr1,OF)
    ideal1:=cr1[1]*OF;
    for i in [2..#cr1] do
        ideal1:=(1/cr1[i])*ideal1^3;
    end for;

    fac1:=Factorization(ideal1);
    S:={@ Place(fac1[i][1]): i in [1..#fac1] @};
    for i in [1..#S] do
        if val_cr3(cr1,S[i]) lt 0 then
             return false;
        end if;
    end for;

    return true;
end function;







//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
///////////// Norm equation solving algorithms            ////////////
//////////////////////////////////////////////////////////////////////
//// When given a polynomial c, the following functions return 
//// a set of non-associate solutions of
//// the norm equation Norm_{F/k(x)}(alpha) = c.
//////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////
///// Gaal-Pohst algorithm
////////////////////////////////////////////////////////////////
// input: a polynomial c, a reduced basis bOF of OF
// output: a set of non-associate solutions of the norm equation
////////////////////////////////////////////////////////////////
function NE_GP(c, bOF)
    F:=Universe(bOF);
    OF:=F`OF;

    error if not(c in CoefficientRing(OF)), "c must be a polynomial";
    error if c eq 0, "c cannot be 0";

    Fq:=ConstantField(F);
    nonzeroFq:={a: a in Fq} diff {Zero(Fq)};

    if c in Fq then
        // handling a trivial case that c is a constant.
        return [c];
    end if;

    q:=#Fq;
    inf:=F`infplaces;
    raminf:=[RamificationIndex(inf[i]): i in [1..#inf]];   


    Minf:=SValMat(inf);

    n:=Degree(DefiningPolynomial(F));

    ////////////Computing the degree bounds for searching
    vc:=(Degree(c)/n);
    vl:=Maximum([ &+[Abs(Minf[j][i])/(2*raminf[i]): j in [1..NumberOfRows(Minf)]]: i in [1..#inf]]);

    norm_omega:=[Maximum([-Valuation(bOF[i], inf[j])/raminf[j]: j in [1..#inf]]): i in [1..#bOF]];

    deg_lambda:=[Maximum(0,Floor(vc+vl-norm_omega[i])): i in [1..#bOF]];
    indbound:=[q^(deg_lambda[i]+1)-1: i in [1..#deg_lambda]];


    // function to enumerate polynomial lambdas
    function polygen(q,ind)
        if ind eq 0 then
            return 0;
        else
            length:=Floor(Log(q, ind))+1;
            polyseq:=[];
            for i in [1..length] do
                polyseq[length-i+1]:=Floor(ind/q^(length-i));
                ind:=ind-polyseq[length-i+1]*q^(length-i);
            end for;
            return Polynomial([polyseq[i]: i in [1..#polyseq]]);
        end if;
    end function;


    // Searching for solutions of the norm equation
    procedure sol_collecting(ind, tempseq, ~R)
        if ind lt #bOF then
            for i in [0..indbound[ind]] do
                $$(ind+1, Insert(Remove(tempseq,ind),ind, tempseq[ind]+i), ~R);
            end for;
        elif ind eq #bOF then
            for i in [0..indbound[ind]] do
                temp:=Insert(Remove(tempseq,ind),ind, tempseq[ind]+i);

                polyseq:=[polygen(q,temp[j]): j in [1..#temp]];
                poly:=&+[OF!polyseq[i]*bOF[i]: i in [1..#bOF]];
                if Norm(poly)/c in nonzeroFq then
                    bool_assoc:=false;
                    for soli in [1..#R] do
                        bool_assoc:=bool_assoc or IsAssociate(poly,R[soli],OF);
                    end for;
                    if not(bool_assoc) then
                        Append(~R, poly);
                    end if;
                end if;
            end for;
        end if;
    end procedure;

    R:=[]; ind:=1; tempseq:=[0: i in [1..#bOF]];


    sol_collecting(ind, tempseq, ~R);


    return R;

end function;








////////////////////////////////////////////////////////////////
///// Gaal-Pohst with compact representations algorithm
////////////////////////////////////////////////////////////////
// input: a polynomial c, a reduced basis bOF of OF
// output: a set of non-associate solutions of the norm equation
////////////////////////////////////////////////////////////////
function NE_GPCR(c, OF)
    F:=FunctionField(OF);

    error if not(c in CoefficientRing(OF)), "c must be a polynomial";
    error if c eq 0, "c cannot be 0";

    Fq:=ConstantField(F);
    nonzeroFq:={a: a in Fq} diff {Zero(Fq)};

    if c in Fq then
        // handling a trivial case that c is a constant.
        return [c];
    end if;

    q:=#Fq;
    inf:=F`infplaces;
    ninf:=#inf;
    raminf:=[RamificationIndex(inf[i]): i in [1..#inf]];   
    deginf:=[Degree(inf[i]): i in [1..#inf]];

    Minf:=SValMat(inf);

    // Form an indexed set S0ind, Sind for the given norm equation, and compute compact representations of a set of fundamental S-units.
    S0ind:={@ Places(F)| p: p in Zeros(F!c)@} join {@ Places(F)| p: p in Poles(F!c)@} diff {@ Places(F)| p: p in InfinitePlaces(F) @};
    degS0ind:=[Degree(S0ind[i]): i in [1..#S0ind]];

    Sind:=S0ind join {@p: p in inf@};

    // indFin: indices of finite places in Sind
    // indInf: indices of infinite places in Sind
    indFin:=[i: i in [1..#Sind] | Sind[i] in S0ind];
    indInf:=[i: i in [1..#Sind] | Sind[i] in inf];

    n:=Degree(DefiningPolynomial(F));


    ////////////Computing the degree bounds for searching
    vc:=[Degree(c)*raminf[i]/n: i in [1..#raminf]];
    vl:=([ &+[Abs(Minf[j][i])/2: j in [1..NumberOfRows(Minf)]]: i in [1..#inf]]);
    valbounds:=[[Ceiling(-vl[i]-vc[i]), Floor(vl[i]-vc[i])]: i in [1..#vl]];




// input: val vector in the bound, ~R
    procedure sol_collecting(temp_v, ind, A, degA, ~R)
        if ind lt #valbounds then
            for i in [valbounds[ind][1]..valbounds[ind][2]] do
                $$(Append(temp_v,i),ind+1, A, degA, ~R);
            end for;
        elif ind eq #valbounds then
            for i in [valbounds[ind][1]..valbounds[ind][2]] do
                inf_vec:=Append(temp_v, i);
                if (degA+&+[inf_vec[j]*deginf[j]: j in [1..ninf]] eq 0) then
                    cr:=compactrep(A, inf_vec, F);
                    if norm_cr(cr)/c in Fq then
                        bool_assoc:=not(CRinOF(cr, OF));
                            Append(~R,cr);
                        break;
                    end if;
                end if;
            end for;
        end if;        
    end procedure;


    R:=[]; 


    procedure enumerate_V(b, temp, ind, ~R)
        if ind lt #b then
            for i in [0..b[ind]] do
                $$(b,Append(temp,i),ind+1,~R);
            end for;
        elif ind eq #b then
            for i in [0..b[ind]] do
                //Append(~vlist, Append(temp, i));
                Vexp:=Append(temp, i);
                if not(IsZero(Vexp)) then
                    A:=&*[Ideal(Sind[i])^Vexp[i]: i in [1..#S0ind]];
                    degA:=&+[degS0ind[i]*Vexp[i]: i in [1..#degS0ind]];
                    sol_collecting([], 1, A, degA, ~R);
                end if;
            end for;
        end if;
    end procedure;


///list of possible finite val vector
    b:=[Valuation(F!c, Sind[indFin[i]]): i in [1..#S0ind]];
    temp:=[]; ind:=1; 
    enumerate_V(b, temp, ind, ~R);

    return R;

end function;





////////////////////////////////////////////////////////////////
///// Principal ideal testing method with Magma intrinsic
////////////////////////////////////////////////////////////////
// input: a polynomial c, the maximal order OF
// output: a set of non-associate solutions in OF of the norm equation
////////////////////////////////////////////////////////////////
function NE_princ(c,OF)
    F:=FunctionField(OF);
    Fq:=ConstantField(F);
    nonzeroFq:={elt: elt in Fq} diff {Fq!0};
 
    if c in Fq then
        return [c];
    else
        inf:=F`infplaces;

        fac_C:=Factorization(c*OF);

        S0ind:={@ Place(fac_C[i][1]): i in [1..#fac_C] @};
        exp:=[fac_C[i][2]: i in [1..#fac_C]];

        Sind:=S0ind join {@p: p in inf@};
        MSc:=SValMat(Sind);
        nrMSc:=NumberOfRows(MSc);

        indFin:=[i: i in [1..#Sind] | Sind[i] in S0ind];
        indInf:=[i: i in [1..#Sind] | Sind[i] in inf];

        MScFin:=Matrix(Integers(), nrMSc, #indFin, [[MSc[i][j] : j in indFin] : i in [1..nrMSc]]); 
        MScInf:=Matrix(Integers(), nrMSc, #inf, [[MSc[i][j] : j in indInf] : i in [1..nrMSc]]);



        procedure idtest(~R, ind, I)
            if ind eq 1 then
                $$(~R, ind+1, I);
                tempI:=I;
 
                for j in [1..exp[ind]] do
                    tempI:=tempI*fac_C[ind][1];
                    if Norm(tempI)/c in nonzeroFq then
                        bool, elt:=IsPrincipal(tempI);
                        if bool then
                            Append(~R, elt);
                    end if;
                    else
                        $$(~R, ind+1, tempI);
                    end if;
                end for;
            elif ind lt #exp then
                $$(~R, ind+1, I);
                tempI:=I;

                for j in [1..exp[ind]] do
                    tempI:=tempI*fac_C[ind][1];

                    if Norm(tempI)/c in nonzeroFq then
                        bool, elt:=IsPrincipal(tempI);
                        if bool then
                            Append(~R, elt);
                        end if;
                    else
                        $$(~R, ind+1, tempI);
                    end if;
                end for;
 
            elif ind eq #exp then
                tempI:=I;
 
                for j in [1..exp[ind]] do
                    tempI:=tempI*fac_C[ind][1]; 
                    if Norm(tempI)/c in nonzeroFq then
                        bool, elt:=IsPrincipal(tempI);
                        if bool then
                            Append(~R, elt);
                        end if;
                    end if;
                end for;
            end if;
        end procedure;

        ind:=1; I:=1*OF; 
        R:=[];


        idtest(~R, ind, I);
        return R;
    end if;
end function;








////////////////////////////////////////////////////////////////
///// Principal ideal testing method, solutions in compact representations
////////////////////////////////////////////////////////////////
// input: a polynomial c, the maximal order OF
// output: a set of non-associate solutions in OF of the norm equation
////////////////////////////////////////////////////////////////
function NE_PrincCR(c, OF)
    F:=FunctionField(OF);
    Fq:=ConstantField(F);
    nonzeroFq:={elt: elt in Fq} diff {Fq!0};
 
    if c in Fq then
        return [[c, 1]];
    else
        inf:=F`infplaces;

        fac_C:=Factorization(c*OF);

        S0ind:={@ Place(fac_C[i][1]): i in [1..#fac_C] @};

        Sind:=S0ind join {@p: p in inf@};


        MSc:=SValMat(Sind);  
        nrMSc:=NumberOfRows(MSc);
        Minf:=SValMat(inf);

        indFin:=[i: i in [1..#Sind] | Sind[i] in S0ind];
        indInf:=[i: i in [1..#Sind] | Sind[i] in inf];

        MSc0:=Matrix(Integers(), nrMSc, #indFin, [[MSc[i][j] : j in indFin] : i in [1..nrMSc]]);
        MScinf:=Matrix(Integers(), nrMSc, #inf, [[MSc[i][j] : j in indInf] : i in [1..nrMSc]]);

        UnitL:=Lattice(Minf);
        MSc0E,MSc0T:=EchelonForm(Transpose(MSc0));
        MSc0T:=Transpose(MSc0T);
        MSc0E:=Transpose(MSc0E);
        procedure idtest(~R, ind, I, tempexp)
            if ind eq 1 then
                $$(~R, ind+1, I, tempexp);

                tempI:=I;
                vfin:=tempexp;

                for j in [1..fac_C[ind][2]] do

                    tempI:=tempI*fac_C[ind][1];
                    vfin[1][ind]:=vfin[1][ind]+1;

                    if Norm(tempI)/c in nonzeroFq then
                    consbool, X:=IsConsistent(MSc0E, vfin*MSc0T);
                        if consbool then
                            vinf:=(X*MScinf)[1];
                            v0:=ClosestVectors(UnitL, vinf);
                            short_v:=[(vinf-v0[1])[i]: i in [1..#inf]];
                            cr:=compactrep(tempI, short_v, F);
                            Append(~R, cr);
                        end if;
                    else
                        $$(~R, ind+1, tempI, vfin);
                    end if;

                 end for;

            elif ind lt #fac_C then
                $$(~R, ind+1, I, tempexp);

                tempI:=I;
                vfin:=tempexp;

                for j in [1..fac_C[ind][2]] do
                    tempI:=tempI*fac_C[ind][1];
                    vfin[1][ind]:=vfin[1][ind]+1;

                    if Norm(tempI)/c in nonzeroFq then

                    consbool, X:=IsConsistent(MSc0E, vfin*MSc0T);
                        if consbool then

                            vinf:=(X*MScinf)[1];

                            v0:=ClosestVectors(UnitL, vinf);
                            short_v:=[(vinf-v0[1])[i]: i in [1..#inf]];
                            cr:=compactrep(tempI, short_v, F);

                                Append(~R, cr);

                        end if;
                    else
                        $$(~R, ind+1, tempI, vfin);

                    end if;

                 end for;


            elif ind eq #fac_C then
    
                tempI:=I;
                vfin:=tempexp;

                for j in [1..fac_C[ind][2]] do
                    tempI:=tempI*fac_C[ind][1]; 
                    vfin[1][ind]:=vfin[1][ind]+1;

                    if Norm(tempI)/c in nonzeroFq then

                    consbool, X:=IsConsistent(MSc0E, vfin*MSc0T);
                        if consbool then
                            vinf:=(X*MScinf)[1];

                            v0:=ClosestVectors(UnitL, vinf);
                            short_v:=[(vinf-v0[1])[i]: i in [1..#inf]];
                            cr:=compactrep(tempI, short_v, F);

                                Append(~R, cr);


                        end if;
                    end if; 
                end for;
            end if;
        end procedure;

        ind:=1; I:=1*OF;   
        tempexp:=ZeroMatrix(Integers(),1,#fac_C);

        R:=[];

        idtest(~R, ind, I, tempexp);
        return R;
    end if;
end function;


